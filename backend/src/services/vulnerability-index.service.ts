import { AppDataSource } from '../data-source';
import { Beneficiario } from '../entities/Beneficiario';
import { Familia } from '../entities/Familia';
import { IndiceVulnerabilidadeFamiliar, FaixaVulnerabilidade } from '../entities/IndiceVulnerabilidadeFamiliar';

interface VulnerabilityFactors {
  rendaPerCapita: number;
  tamanhoFamilia: number;
  criancas: number;
  idosos: number;
  pessoasComDeficiencia: number;
  condicaoHabitacional: number;
  frequenciaAtendimentos: number;
}

export class VulnerabilityIndexService {
  private readonly beneficiaryRepo = AppDataSource.getRepository(Beneficiario);
  private readonly familyRepo = AppDataSource.getRepository(Familia);
  private readonly indexRepo = AppDataSource.getRepository(IndiceVulnerabilidadeFamiliar);

  /**
   * Regra de pontuação (ajustável):
   * - Renda per capita (quanto menor, maior a pontuação)
   *   <= 1/4 SM: +40 | <= 1/2 SM: +25 | <= 1 SM: +10 | acima: +0
   * - Tamanho da família (maior núcleo tende a elevar vulnerabilidade):
   *   >= 6: +15 | 4-5: +10 | 3: +5 | <=2: +0
   * - Crianças: +5 por criança até 2 (máx +10)
   * - Idosos: +5 por idoso até 2 (máx +10)
   * - Pessoas com deficiência: +8 por pessoa até 2 (máx +16)
   * - Condição habitacional (falta de saneamento/energia/internet/situação precária):
   *   pontuação calculada de 0 a 12 (3 pontos por flag negativa)
   * - Frequência de atendimentos (quanto mais atendimentos, maior a pontuação atual):
   *   0-1: +0 | 2-5: +5 | 6-10: +10 | >10: +15
   */
  private computeScore(factors: VulnerabilityFactors): number {
    const rendaScore = factors.rendaPerCapita <= 0.25
      ? 40
      : factors.rendaPerCapita <= 0.5
        ? 25
        : factors.rendaPerCapita <= 1
          ? 10
          : 0;

    const tamanhoScore = factors.tamanhoFamilia >= 6 ? 15 : factors.tamanhoFamilia >= 4 ? 10 : factors.tamanhoFamilia === 3 ? 5 : 0;

    const criancasScore = Math.min(factors.criancas, 2) * 5;
    const idososScore = Math.min(factors.idosos, 2) * 5;
    const pcdScore = Math.min(factors.pessoasComDeficiencia, 2) * 8;
    const habitacionalScore = Math.min(factors.condicaoHabitacional, 12);

    const freqScore = factors.frequenciaAtendimentos > 10
      ? 15
      : factors.frequenciaAtendimentos > 5
        ? 10
        : factors.frequenciaAtendimentos > 1
          ? 5
          : 0;

    return rendaScore + tamanhoScore + criancasScore + idososScore + pcdScore + habitacionalScore + freqScore;
  }

  private resolveFaixa(score: number): FaixaVulnerabilidade {
    if (score >= 70) return 'Crítica';
    if (score >= 50) return 'Alta';
    if (score >= 30) return 'Média';
    return 'Baixa';
  }

  private extractHabitacionalScore(family?: Familia | null): number {
    if (!family) return 0;
    let score = 0;
    if (!family.aguaEncanada) score += 3;
    if (!family.esgotoTipo || family.esgotoTipo === 'NAO_POSSUI' || family.esgotoTipo === 'CEU_ABERTO') score += 3;
    if (!family.energiaEletrica) score += 3;
    if (!family.internet) score += 3;
    return score;
  }

  private extractIncomePerCapita(family?: Familia | null): number {
    if (!family) return Number.POSITIVE_INFINITY;
    const renda = Number(family.rendaPerCapita ?? family.rendaFamiliarTotal ?? 0);
    if (!Number.isFinite(renda)) return Number.POSITIVE_INFINITY;
    return renda;
  }

  private buildFactors(beneficiario: Beneficiario, family?: Familia | null): VulnerabilityFactors {
    const tamanhoFamilia = family?.qtdMembros && family.qtdMembros > 0 ? family.qtdMembros : 1;
    return {
      rendaPerCapita: this.extractIncomePerCapita(family),
      tamanhoFamilia,
      criancas: family?.qtdCriancas ?? 0,
      idosos: family?.qtdIdosos ?? 0,
      pessoasComDeficiencia: family?.qtdPessoasDeficiencia ?? (beneficiario.possuiDeficiencia ? 1 : 0),
      condicaoHabitacional: this.extractHabitacionalScore(family),
      // frequência de atendimentos será ajustada futuramente quando houver fonte; por ora usamos 0 como padrão
      frequenciaAtendimentos: 0
    };
  }

  async recalculateForBeneficiary(idBeneficiario: string): Promise<IndiceVulnerabilidadeFamiliar> {
    const beneficiario = await this.beneficiaryRepo.findOne({ where: { idBeneficiario } });
    if (!beneficiario) {
      throw new Error('Beneficiário não encontrado');
    }

    const family = await this.familyRepo.findOne({ where: { idReferenciaFamiliar: idBeneficiario } });
    const factors = this.buildFactors(beneficiario, family);
    const pontuacaoTotal = this.computeScore(factors);
    const faixaVulnerabilidade = this.resolveFaixa(pontuacaoTotal);

    const existing = await this.indexRepo.findOne({ where: { idBeneficiario } });
    const toSave = existing
      ? { ...existing, pontuacaoTotal, faixaVulnerabilidade, dataCalculo: new Date() }
      : this.indexRepo.create({ idBeneficiario, pontuacaoTotal, faixaVulnerabilidade });

    return this.indexRepo.save(toSave);
  }

  async recalculateAll(): Promise<IndiceVulnerabilidadeFamiliar[]> {
    const beneficiarios = await this.beneficiaryRepo.find({ select: ['idBeneficiario'] });
    const results: IndiceVulnerabilidadeFamiliar[] = [];

    for (const beneficiario of beneficiarios) {
      results.push(await this.recalculateForBeneficiary(beneficiario.idBeneficiario));
    }

    return results;
  }
}
